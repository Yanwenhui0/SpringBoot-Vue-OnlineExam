/*
Navicat MySQL Data Transfer

Source Server         : YWH_Connection
Source Server Version : 50720
Source Host           : localhost:3306
Source Database       : exam

Target Server Type    : MYSQL
Target Server Version : 50720
File Encoding         : 65001

Date: 2020-06-02 15:06:43
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `admin`
-- ----------------------------
DROP TABLE IF EXISTS `admin`;
CREATE TABLE `admin` (
  `adminId` int(9) NOT NULL AUTO_INCREMENT COMMENT 'ID号',
  `adminName` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '姓名',
  `sex` varchar(2) COLLATE utf8_bin DEFAULT NULL COMMENT '性别',
  `tel` varchar(11) COLLATE utf8_bin DEFAULT NULL COMMENT '电话号码',
  `email` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '电子邮箱',
  `pwd` varchar(16) COLLATE utf8_bin DEFAULT NULL COMMENT '密码',
  `cardId` varchar(18) COLLATE utf8_bin DEFAULT NULL COMMENT '身份证号',
  `role` varchar(1) COLLATE utf8_bin DEFAULT NULL COMMENT '角色(0管理员，1教师，2学生)',
  PRIMARY KEY (`adminId`) USING BTREE,
  KEY `sex` (`sex`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=9528 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='管理员信息表';

-- ----------------------------
-- Records of admin
-- ----------------------------
INSERT INTO `admin` VALUES ('9527', '超级管理员', '男', '18262552709', '1697479326@qq.com', '123456', '3132', '0');

-- ----------------------------
-- Table structure for `exam_manage`
-- ----------------------------
DROP TABLE IF EXISTS `exam_manage`;
CREATE TABLE `exam_manage` (
  `examCode` int(9) NOT NULL AUTO_INCREMENT COMMENT '考试编号',
  `description` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '该次考试介绍',
  `source` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '课程名称',
  `paperId` int(10) DEFAULT NULL COMMENT '试卷编号',
  `examDate` varchar(10) COLLATE utf8_bin DEFAULT NULL COMMENT '考试日期',
  `totalTime` int(3) DEFAULT NULL COMMENT '持续时长',
  `grade` varchar(10) COLLATE utf8_bin DEFAULT NULL COMMENT '年级',
  `term` varchar(10) COLLATE utf8_bin DEFAULT NULL COMMENT '学期',
  `major` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '专业',
  `institute` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '学院',
  `totalScore` int(4) DEFAULT NULL COMMENT '总分',
  `type` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '考试类型',
  `tips` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '考生须知',
  PRIMARY KEY (`examCode`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=20190016 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='考试管理表';

-- ----------------------------
-- Records of exam_manage
-- ----------------------------
INSERT INTO `exam_manage` VALUES ('20190001', '2019年上期期末考试', '计算机网络', '1001', '2019-03-21', '120', '2018', '1', '计算机科学与技术', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190002', '2019年上期期末考试', '数据库理论', '1002', '2019-03-07', '90', '2018', '2', '网络工程', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190003', '2018年下期期末考试', '数据结构', '1003', '2019-02-27', '90', '2017', '1', '软件工程', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190005', '2018年上期期末考试', '计算机导论', '1004', '2019-03-14', '90', '2018', '1', '计算机科学与技术', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190006', '2017年上期期末考试', '软件工程', '1005', '2019-03-21', '120', '2018', '1', '计算机科学与技术', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190007', '2018年上期期末考试', '操作系统', '1006', '2019-03-13', '120', '2018', '2', '计算机科学与技术', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190008', '2018年下期期末考试', 'C语言', '1007', '2019-03-13', '120', '2018', '1', '信息工程', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190009', '2018年上期期末考试', '高等数学', '1008', '2019-03-07', '90', '2018', '1', '信息工程', '软件工程学院', '100', '期末考试', '快乐千万条，学习第一条，平时不努力，考试两行泪。');
INSERT INTO `exam_manage` VALUES ('20190013', '测试', '测试', '1009', '2019-04-24', '120', '2017', null, '测试', '测试', '100', '期末考试', '请不要带与考试无关的书籍。');
INSERT INTO `exam_manage` VALUES ('20190014', 'test', 'test001', '1010', '2019-11-30', '120', '大四', null, '软件工程', '计算机与信息工程学院', '100', '考试', '不要带笔');
INSERT INTO `exam_manage` VALUES ('20190015', 'tttt', '网络层', '1011', '2019-12-10', '120', '大三', null, '软件工程', '计算机与信息工程学院', '100', '考试', '不用代笔');

-- ----------------------------
-- Table structure for `exercise`
-- ----------------------------
DROP TABLE IF EXISTS `exercise`;
CREATE TABLE `exercise` (
  `exerciseId` int(9) NOT NULL AUTO_INCREMENT,
  `studentId` int(9) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  `subject` varchar(50) DEFAULT NULL,
  `remark` varchar(100) DEFAULT NULL,
  `score` int(5) DEFAULT '0',
  `total` int(5) DEFAULT '0',
  `multi` varchar(255) DEFAULT NULL,
  `fill` varchar(255) DEFAULT NULL,
  `judge` varchar(255) DEFAULT NULL,
  `created` date DEFAULT NULL,
  PRIMARY KEY (`exerciseId`),
  KEY `sid` (`studentId`),
  CONSTRAINT `sid` FOREIGN KEY (`studentId`) REFERENCES `student` (`studentId`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of exercise
-- ----------------------------
INSERT INTO `exercise` VALUES ('1', '20154084', '我的test', '计算机网络', 'tttest', '0', '18', '10030,10027,10026', '10011,10010,10007', '10013,10003,10012', '2019-12-10');
INSERT INTO `exercise` VALUES ('2', '20154084', 'good', '计算机网络', 'hao', '0', '30', '10005,10004,10021,10023,10024', '10001,10011,10000,10003,10005', '10011,10008,10009,10002,10010', '2019-12-11');
INSERT INTO `exercise` VALUES ('3', '20154084', '又是一个练习', '计算机网络', '这次还是计算机网络，这次多加点题目，多练练，多练才能挂科，逢考避过，网络必挂，必挂万岁，万岁万岁万万岁！！！', '0', '52', '10030,10028,10020,10021,10003,10024,10026,10001,10029,10007', '10000,10001,10014,10004,10005,10010,10012,10009', '10003,10008,10004,10007,10013,10002,10001,10010', '2019-12-10');
INSERT INTO `exercise` VALUES ('4', '20154084', '在来一个短的', '计算机网络', '好短', '0', '6', '10024', '10008', '10003', '2019-12-10');

-- ----------------------------
-- Table structure for `fill_question`
-- ----------------------------
DROP TABLE IF EXISTS `fill_question`;
CREATE TABLE `fill_question` (
  `questionId` int(9) NOT NULL AUTO_INCREMENT COMMENT '试题编号',
  `question` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '试题内容',
  `answer` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '正确答案',
  `analysis` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '题目解析',
  `score` int(2) DEFAULT '2' COMMENT '分数',
  `level` varchar(5) COLLATE utf8_bin DEFAULT NULL COMMENT '难度等级',
  `subject` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '所属章节',
  `collect` int(9) DEFAULT '0',
  `ok` int(9) DEFAULT '0',
  `total` int(9) DEFAULT '0',
  PRIMARY KEY (`questionId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=10029 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='填空题题库';

-- ----------------------------
-- Records of fill_question
-- ----------------------------
INSERT INTO `fill_question` VALUES ('10000', '从计算机网络系统组成的角度看，计算机网络可以分为()和()', '通信子网资源子网', null, '4', '3', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10001', '收发电子邮件，属于ISO/OSI RM中 ()层的功能。', '应用', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10002', '在TCP/IP层次模型中与OSI参考模型第四层相对应的主要协议有()和(),其中后者提供无连接的不可靠传输服', 'TCP（传输控制协议） UDP（用户数据报协议） ', null, '4', '2', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10003', '计算机网络中常用的三种有线媒体是 (),()和 ()', '同轴电缆.双绞线 光纤', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10004', '国内最早的四大网络包括原邮电部的ChinaNet. 原电子部的ChinaGBN. 教育部的()和中科院的CSTnet', 'CERnet (或中国教育科研网)', null, '4', '4', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10005', '复盖一个国家，地区或几个洲的计算机网络称为()，在同一建筑或复盖几公里内范围的网络称为()，而介于两者之间的是()', ' 广域网       局域网     城域网', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10006', 'Outlook等常用电子邮件软件接收邮件使用的协议是(),发送邮件时使用的协议是()', 'POP3    SMTP    ', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10007', '通信系统中，称调制前的电信号为()信号，调制后的信号为调制信号', '基带', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10008', '按照IPV4标准,IP地址205.3.127.13属于()类地址', 'C', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10009', '计算机网络采用()技术，而传统电话网络则采用()技术', '分组交换电路交换', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10010', '计算机内传输的信号是()，而公用电话系统的传输系统只能传输()', '数字信号模拟信号', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10011', '通信系统中，称调制前的电信号为()，调制后的信号叫()。', '基带信号调制信号', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10012', 'IP地址分()和()两个部分', '网络号主机号', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10013', ' IP地址协议作网间网中()层协议，提供无连接的数据报传输机制，IP数据报也分为()和()两个部分', '网络报头数据区', null, '4', '2', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10014', '()是一个简单的远程终端协议。', 'TELNET', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10015', '在同一个系统内，相邻层之间交换信息的连接点称之为()，而低层模块向高层提供功能性的支持称之为()。', '接口服务', null, '4', '1', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10016', 'Internet广泛使用的电子邮件传送协议是()', 'SMTP', null, '4', '1', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10017', '按交换方式来分类，计算机网络可以分为电路交换网，  报文交换网  和()三种', '分组交换网', null, '4', '3', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10018', 'Intranet分层结构包括网络、(),应用三个层次。', '服务', null, '4', '1', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10019', 'WWW上的每一个网页都有一个独立的地址，这些地址称为  ()', '统一资源定位器/URL ', null, '4', '2', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10020', '分组交换网中，附加信息用来在网络中进行路由选择、() 和流量控制', '差错纠正  ', null, '4', '4', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10021', '根据IEEE802模型的标准将数据链路层划分为LLC子层和 ()子层。', ' MAC ', null, '4', '3', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10022', '据交换的路由信息的不同，路由算法可以分为两大类：  ()  和链路状态算法', '距离向量算法', null, '4', '3', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10023', '假定某信道受奈氏准则限制的最高码元速率为2000码元/秒。如果采用振幅调制，把码元的振幅划分为16个不同等级来传送，那么可以获得的数据率为 () b/s。', '80000 ', null, '4', '5', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10024', '交换型以太网系统中的 ()  ，以其为核心联接站点或者网段，端口之间帧的输入和输出已不再受到CSMA/CD媒体访问控制协议的约束。', '以太网交换器 ', null, '4', '5', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10025', '局域网络参考模型是以 ()标准为基础的', 'IEEE802', null, '4', '5', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10026', '路由器的核心是 () 。', ' 路由表', null, '4', '3', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10027', '若 HDLC 帧数据段中出现比特串“ 01011111110 ”，则比特填充后的输出为()', '10111110110', null, '4', '5', '操作系统', '0', '0', '0');
INSERT INTO `fill_question` VALUES ('10028', '数字调制的三种基本形式：移幅键控法ASK、 ()、移相键控法PSK', '移频键控法FSK', null, '4', '5', '操作系统', '0', '0', '0');

-- ----------------------------
-- Table structure for `judge_question`
-- ----------------------------
DROP TABLE IF EXISTS `judge_question`;
CREATE TABLE `judge_question` (
  `questionId` int(9) NOT NULL AUTO_INCREMENT COMMENT '试题编号',
  `question` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '试题内容',
  `answer` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '正确答案',
  `analysis` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '题目解析',
  `score` int(2) DEFAULT '2' COMMENT '分数',
  `level` varchar(1) COLLATE utf8_bin DEFAULT NULL COMMENT '难度等级',
  `subject` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '所属章节',
  `collect` int(1) DEFAULT '0',
  `ok` int(9) DEFAULT '0',
  `total` int(9) DEFAULT '0',
  PRIMARY KEY (`questionId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=10014 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='判断题题库表';

-- ----------------------------
-- Records of judge_question
-- ----------------------------
INSERT INTO `judge_question` VALUES ('10001', '与有线网相比,无线网的数据传输率一般相对较慢', 'T', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10002', 'OSI参考模型中,不同节点的同等层具有不同的功能', 'F', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10003', '普通电脑不能作为服务器', 'F', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10004', '没有网线的电脑不能连入互联网', 'F', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10005', '网卡必须安装驱动程序', 'T', null, '4', '2', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10006', 'UTP为屏蔽双绞线', 'F', null, '4', '2', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10007', '网络接口卡又称为网卡,它是构成网络的基本部件', 'T', null, '4', '2', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10008', '无线AP可以成倍地扩展网络覆盖范围', 'T', null, '4', '3', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10009', 'SMTP是一组用于由源地址到目的地址传送邮件的协议', 'T', null, '4', '4', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10010', '任务管理器可以关闭所有的进程', 'F', null, '4', '3', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10011', '利用BT下载时,用户越多,下载速度越快', 'T', null, '4', '2', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10012', 'INTERNET上向朋友发送电子邮件,必须知道对方的真实姓名和家庭住址', 'F', null, '4', '1', '计算机网络', '0', '0', '0');
INSERT INTO `judge_question` VALUES ('10013', '1234', 'F', '', '4', '3', '计算机网络', '0', '0', '0');

-- ----------------------------
-- Table structure for `message`
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` int(9) NOT NULL AUTO_INCREMENT COMMENT '留言编号',
  `title` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '标题',
  `content` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '留言内容',
  `time` date DEFAULT NULL COMMENT '留言时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='留言表';

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES ('2', '晚上加班,这感觉非常的nice', '今天是星期一的晚上,下班后回到宿舍继续写我的毕业设计,看着项目功能日渐丰满好开心哦,你们也要元气满满哦！', '2019-03-18');
INSERT INTO `message` VALUES ('15', '咸鱼', '我是一条咸鱼', '2019-03-18');
INSERT INTO `message` VALUES ('16', '今天中午吃什么', '今天去吃莲藕排骨汤吧，虽然也不好吃，但这里真的没什么东西可以吃了', '2019-03-18');
INSERT INTO `message` VALUES ('20', '这个网站不错', '博主大大好厉害，网页看着很清新呢，喜欢这样嘞风格。', '2019-03-18');
INSERT INTO `message` VALUES ('21', '男孩子', '哇，这么可爱，那肯定是男孩子呀。', '2019-03-18');
INSERT INTO `message` VALUES ('22', '好人', '你是个好人，可是我们不合适。', '2019-03-18');
INSERT INTO `message` VALUES ('25', '小乔', '花会枯萎，爱永不凋零，小乔要努力变强。', '2019-03-18');
INSERT INTO `message` VALUES ('26', '妲己', '妲己会一直爱主人，因为被设定成这样，来和妲己玩耍吧。', '2019-03-18');
INSERT INTO `message` VALUES ('27', '土味情话', '妈妈从小对我讲，不要早恋，遇到你以后，我决定不听妈妈的话了。', '2019-03-31');
INSERT INTO `message` VALUES ('35', '贝塔', '开坦克', '2019-09-05');
INSERT INTO `message` VALUES ('36', 'qqqqqq', '1111111', '2019-11-26');
INSERT INTO `message` VALUES ('37', '哈哈哈', '不知道说些什么啊\n', '2020-01-10');

-- ----------------------------
-- Table structure for `multi_question`
-- ----------------------------
DROP TABLE IF EXISTS `multi_question`;
CREATE TABLE `multi_question` (
  `questionId` int(9) NOT NULL AUTO_INCREMENT COMMENT '试题编号',
  `question` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '问题题目',
  `answerA` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '选项A',
  `answerB` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '选项B',
  `answerC` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '选项C',
  `answerD` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '选项D',
  `rightAnswer` varchar(10) COLLATE utf8_bin DEFAULT NULL COMMENT '正确答案',
  `analysis` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '题目解析',
  `score` int(2) DEFAULT '2' COMMENT '分数',
  `subject` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '所属章节',
  `level` varchar(1) COLLATE utf8_bin DEFAULT NULL COMMENT '难度等级',
  `collect` int(1) DEFAULT '0',
  `ok` int(9) DEFAULT '0',
  `total` int(9) DEFAULT '0',
  PRIMARY KEY (`questionId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=10033 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='选择题题库表';

-- ----------------------------
-- Records of multi_question
-- ----------------------------
INSERT INTO `multi_question` VALUES ('10000', 'DNS 服务器和DHCP服务器的作用是（）', '将IP地址翻译为计算机名，为客户机分配IP地址', '将IP地址翻译为计算机名、解析计算机的MAC地址', '将计算机名翻译为IP地址、为客户机分配IP地址', '将计算机名翻译为IP地址、解析计算机的MAC地址', 'C', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10001', 'HTTP协议通常使用什么协议进行传输（）', 'ARP', 'DHCP', 'UDP', 'TCP', 'D', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10003', '查看DNS缓存记录的命令（）', 'ipconfig/displaydns', 'nslookup', 'ipconfig/release', 'ipconfig/flushdns', 'A', null, '4', '计算机网络', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10004', 'DHCP(        )报文的目的IP地址为255.255.255.255', 'DhcpDisover', 'DhcpOffer', 'DhcpAck', 'DhcpNack', 'A', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10005', '下列地址中，（  ）不是DHCP服务器分配的IP地址', '196.254.109.100', '169.254.12.42', '69.254.48.45', '96.254.54.15', 'B', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10006', 'DHCP通常可以为客户端自动配置哪些网络参数（）', 'IP，掩码，网关，DNS', 'IP，掩码，域名，SMTP', '网关，掩码，浏览器，FTP', 'IP，网关，DNS，服务器', 'A', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10007', 'DNS服务器在名称解析过程中正确的查询顺序为（）', '本地缓存记录→区域记录→转发域名服务器→根域名服务器', '区域记录→本地缓存记录→转发域名服务器→根域名服务器', '本地缓存记录→区域记录→根域名服务器→转发域名服务器', '区域记录→本地缓存记录→根域名服务器→转发域名服务器', 'A', null, '4', '计算机网络', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10008', '在TCP/IP协议中，序号小于（  ）的端口称为熟知端口(well-known port)。', '1024', '64', '256', '128', 'A', null, '4', '操作系统', '1', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10009', '在Internet上用TCP/IP播放视频，想用传输层的最快协议，以减少时延，要使用（ ）', 'UDP协议的低开销特性', 'UDP协议的高开销特性', 'TCP协议的低开销特性', 'TCP协议的高开销特性', 'A', null, '4', '操作系统', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10010', '在TCP协议中采用（ ）来区分不同的应用进程', '端口号', 'IP地址', '协议类型', 'MAC地址', 'A', null, '4', '操作系统', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10011', '可靠的传输协议中的“可靠”指的是（ ）', '使用面向连接的会话', '使用“尽力而为”的传输', '使用滑动窗口来维持可靠性', '使用确认重传机制来确保传输的数据不丢失', 'D', null, '4', '操作系统', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10012', '假设拥塞窗口为50KB，接收窗口为80KB，TCP能够发送的最大字节数为（ ）', '50KB', '80KB', '130KB', '30KB', 'A', null, '4', '操作系统', '4', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10013', '主机A向主机B发送一个（SYN=1，seq=2000）的TCP报文，期望与主机B建立连接，若主机B接受连接请求，则主机B发送的正确有TCP报文可能是（ ）', '（SYN=0,ACK=0,seq=2001,ack=2001）', '（SYN=1,ACK=1,seq=2000,ack=2000）', '•	C.（SYN=1,ACK=1,seq=2001,ack=2001）', '（SYN=0,ACK=1,seq=2000,ack=2000）', 'C', null, '4', '操作系统', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10014', '主机A向主机B连续发送了两个TCP报文段，其序号分别为70和100。试问： （1）第一个报文段携带了（）个字节的数据？', ' 70', '30', '100', '170', 'B', null, '4', '操作系统', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10015', 'PCM脉码调制的过程（ ）', '采样、量化、编码', '量化、编码、采样', '编码、量化、采样', '采样、编码、量化', 'A', null, '4', '计算机硬件基础', '4', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10016', '若某采用4相位调制的通信链路的数据传输速率为2400bps，则该链路的波特率为（）', '600Baud', '1200Baud', '4800Baud', '9600Baud', 'B', null, '4', '计算机硬件基础', '1', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10017', '以下关于数据传输速率的描述中，错误的是( )', '数据传输速率表示每秒钟传输构成数据代码的二进制比特数', '对于二进制数据，数据传输速率为S=1/T (bps)', '常用的数据传输速率单位有: 1Mbps=1.024×106bps', '数据传输速率是描述数据传输系统性能的重要技术指标之一', 'C', null, '4', '计算机硬件基础', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10018', '以下关于时分多路复用概念的描述中，错误的是.(  ).', '时分多路复用将线路使用的时间分成多个时间片', '时分多路复用分为同步时分多路复用与统计时分多路复用', '时分多路复用使用“帧”与数据链路层“帧”的概念、作用是不同的', '统计时分多路复用将时间片预先分配给各个信道', 'D', null, '4', '计算机硬件基础', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10019', '1000BASE-T标准支持的传输介质是（）', '双绞线', '同轴电缆', '光纤', '无线电', 'A', null, '4', '计算机硬件基础', '1', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10020', '一个以太网交换机，读取整个数据帧，对数据帧进行差错校验后再转发出去，这种交换方式称为 （）', '直通交换', '无碎片交换', '无差错交换', '存储转发交换', 'D', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10021', '关于VLAN，下面的描述中正确的是（）', '一个新的交换机没有配置VLAN', '通过配置VLAN减少了冲突域的数量', '一个VLAN不能跨越多个交换机', '各个VLAN属于不同的广播域', 'D', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10022', '以太网协议中使用物理地址作用是什么？', '.用于不同子网中的主机进行通信', '作为第二层设备的唯一标识', '用于区别第二层第三层的协议数据单元', '保存主机可检测未知的远程设备', 'B', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10023', '以太网采用的CSMA/CD协议，当冲突发生时要通过二进制指数后退算法计算后退延时， 关于这个算法，以下论述中错误的是 （）', '冲突次数越多，后退的时间越短', '平均后退次数的多少与负载大小有关', '后退时延的平均值与负载大小有关', '重发次数达到一定极限后放弃发送', 'A', null, '4', '计算机网络', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10024', '以下关于交换机获取与其端口连接设备的MAC地址的叙述中，正确的是（）', '交换机从路由表中提取设备的MAC地址', '交换机检查端口流入分组的源地址', '交换机之间互相交换地址表', '网络管理员手工输入设备的MAC地址', 'B', null, '4', '计算机网络', '2', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10025', '如果G (x）为11010010，以下4个CRC校验比特序列中只有哪个可能是正确的 ？', '1101011001', '101011011', '11011011', '1011001', 'B', null, '4', '计算机网络', '1', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10026', '以下关于Ethernet物理地址的描述中，错误的是', 'Ethernet物理地址又叫做MAC地址', '48位的Ethernet物理地址允许分配的地址数达到247个', '网卡的物理地址写入主机的EPROM中', '每一块网卡的物理地址在全世界是唯一的', 'C', null, '4', '计算机网络', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10027', '下列帧类型中，不属于HDLC帧类型的是（）', '信息帧', '确认帧', '监控帧', '无编号帧', 'B', null, '4', '计算机网络', '1', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10028', '通过交换机连接的一组站点，关于它们的广播域和冲突域说法正确的是（）', '组成一个冲突域，但不是一个广播域', '组成一个广播域，但不是一个冲突域', '组成一个冲突域，也是一个广播域', '既不一个冲突域，也不是一个广播域', 'B', null, '4', '计算机网络', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10029', '数据链路层的数据单位是（）', '帧', '字节', '比特', '分组', 'A', null, '4', '计算机网络', '1', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10030', 'LAN参考模型可分为物理层、（ ）', 'MAC，LLC等三层', 'LLC，MHS等三层', 'MAC，FTAM等三层', 'LLC，VT等三层', 'A', null, '4', '计算机网络', '3', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10031', '测试', 'A', 'B', 'C', 'D', 'B', '解析', '4', '操作系统', '4', '0', '0', '0');
INSERT INTO `multi_question` VALUES ('10032', 'DNS 服务器和DHCP服务器的作用是（）', 'A', 'B', 'C', 'D', 'B', '哦解析', '4', '操作系统', '2', '0', '0', '0');

-- ----------------------------
-- Table structure for `note`
-- ----------------------------
DROP TABLE IF EXISTS `note`;
CREATE TABLE `note` (
  `noteId` varchar(50) NOT NULL,
  `studentId` varchar(50) NOT NULL,
  `title` varchar(30) NOT NULL,
  `content` longtext,
  `createTime` datetime DEFAULT NULL,
  `updateTime` datetime DEFAULT NULL,
  PRIMARY KEY (`noteId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of note
-- ----------------------------
INSERT INTO `note` VALUES ('121f0aa2c714cb82694be77b9e59f89d', '20154001', '第四个', '# 第四个\n萨嘎', '2020-05-13 11:37:34', '2020-05-28 05:34:49');
INSERT INTO `note` VALUES ('145718410468d401235805a50216f512', '20154001', '第三个', '# 第三个', '2020-05-13 11:30:27', '2020-05-13 11:37:16');
INSERT INTO `note` VALUES ('959c11aa61e428861749068d110252e1', '20154001', '爱上覅回归哦哈过化工慧慧更舒服点东风的', '#### 四级标题', '2020-04-16 14:17:37', '2020-05-13 11:37:03');
INSERT INTO `note` VALUES ('ea59eafa0925372562271c16558a2a07', '20154001', 'MQ介绍', '# 1. MQ介绍\n\n## 1.1 为什么要用MQ\n\n消息队列是一种“先进先出”的数据结构\n\n![](img/queue1.png)\n\n其应用场景主要包含以下3个方面\n\n- 应用解耦\n\n系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。\n\n![](img/解耦1.png)\n\n使用消息队列解耦合，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统回复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。\n\n![](img/解耦2.png)\n\n- 流量削峰\n\n![](img/mq-5.png)\n\n应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。\n\n![](img/mq-6.png)\n\n一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总不能下单体验要好。\n\n<u>处于经济考量目的：</u>\n\n业务系统正常时段的QPS如果是1000，流量最高峰是10000，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量削峰\n\n- 数据分发\n\n![](img/mq-1.png)\n\n通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可\n\n![](img/mq-2.png)\n\n## 1.2 MQ的优点和缺点\n\n优点：解耦、削峰、数据分发\n\n缺点包含以下几点：\n\n- 系统可用性降低\n\n  系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。\n\n  如何保证MQ的高可用？\n\n- 系统复杂度提高\n\n  MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。\n\n  如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？\n\n- 一致性问题\n\n  A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。\n\n  如何保证消息数据处理的一致性？\n\n## 1.3 各种MQ产品的比较\n\n常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。 \n\n![](img/MQ比较.png)\n\n# 2. RocketMQ快速入门\n\nRocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，在阿里内部，RocketMQ承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。\n\n## 2.1 准备工作\n\n### 2.1.1 下载RocketMQ\n\nRocketMQ最新版本：4.5.1\n\n[下载地址](https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.1/rocketmq-all-4.5.1-bin-release.zip)\n\n### 2.2.2 环境要求\n\n- Linux64位系统\n- JDK1.8(64位)\n- 源码安装需要安装Maven 3.2.x\n\n## 2.2 安装RocketMQ\n\n### 2.2.1 安装步骤\n\n本教程以二进制包方式安装\n\n1. 解压安装包\n2. 进入安装目录\n\n### 2.2.2 目录介绍\n\n- bin：启动脚本，包括shell脚本和CMD脚本\n- conf：实例配置文件 ，包括broker配置文件、logback配置文件等\n- lib：依赖jar包，包括Netty、commons-lang、FastJSON等\n\n## 2.3 启动RocketMQ\n\n1. 启动NameServer\n\n```shell\n# 1.启动NameServer\nnohup sh bin/mqnamesrv &\n# 2.查看启动日志\ntail -f ~/logs/rocketmqlogs/namesrv.log\n```\n\n1. 启动Broker\n\n```shell\n# 1.启动Broker\nnohup sh bin/mqbroker -n localhost:9876 &\n# 2.查看启动日志\ntail -f ~/logs/rocketmqlogs/broker.log \n```\n\n- 问题描述：\n\n  RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小\n\n```shell\n# 编辑runbroker.sh和runserver.sh修改默认JVM大小\nvi runbroker.sh\nvi runserver.sh\n```\n\n- 参考设置：\n\n```JAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m  -XX:MaxMetaspaceSize=320m\"```\n\n## 2.4 测试RocketMQ\n\n### 2.4.1 发送消息\n\n```sh\n# 1.设置环境变量\nexport NAMESRV_ADDR=localhost:9876\n# 2.使用安装包的Demo发送消息\nsh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer\n```\n\n### 2.4.2 接收消息\n\n```shell\n# 1.设置环境变量\nexport NAMESRV_ADDR=localhost:9876\n# 2.接收消息\nsh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer\n```\n\n## 2.5 关闭RocketMQ\n\n```shell\n# 1.关闭NameServer\nsh bin/mqshutdown namesrv\n# 2.关闭Broker\nsh bin/mqshutdown broker\n```\n\n# 3. RocketMQ集群搭建\n\n## 3.1 各角色介绍\n\n- Producer：消息的发送者；举例：发信者\n- Consumer：消息接收者；举例：收信者\n- Broker：暂存和传输消息；举例：邮局\n- NameServer：管理Broker；举例：各个邮局的管理机构\n- Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息\n- Message Queue：相当于是Topic的分区；用于并行发送和接收消息\n\n![](img/RocketMQ角色.jpg)\n\n## 3.2 集群搭建方式\n\n### 3.2.1 集群特点\n\n- NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。\n- Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。\n- Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。\n- Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。\n\n### 3.2.3 集群模式\n\n#### 1）单Master模式\n\n这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。\n\n#### 2）多Master模式\n\n一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：\n\n- 优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；\n- 缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。\n\n#### 3）多Master多Slave模式（异步）\n\n每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：\n\n- 优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；\n- 缺点：Master宕机，磁盘损坏情况下会丢失少量消息。\n\n#### 4）多Master多Slave模式（同步）\n\n每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：\n\n- 优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；\n- 缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。\n\n## 3.3 双主双从集群搭建\n\n### 3.3.1 总体架构\n\n消息高可用采用2m-2s（同步双写）方式\n\n![](img/RocketMQ集群.png)\n\n### 3.3.2 集群工作流程\n\n1. 启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。\n2. Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。\n3. 收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。\n4. Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。\n5. Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。\n\n### 3.3.3 服务器环境\n\n| **序号** | **IP**         | **角色**                  | **架构模式**       |\n| ------ | -------------- | ----------------------- | -------------- |\n| 1      | 192.168.25.135 | nameserver、brokerserver | Master1、Slave2 |\n| 2      | 192.168.25.138 | nameserver、brokerserver | Master2、Slave1 |\n\n### 3.3.4 Host添加信息\n\n```bash\nvim /etc/hosts\n```\n\n配置如下:\n\n```bash\n# nameserver\n192.168.25.135 rocketmq-nameserver1\n192.168.25.138 rocketmq-nameserver2\n# broker\n192.168.25.135 rocketmq-master1\n192.168.25.135 rocketmq-slave2\n192.168.25.138 rocketmq-master2\n192.168.25.138 rocketmq-slave1\n```\n\n配置完成后, 重启网卡\n\n```bash\nsystemctl restart network\n```\n\n### 3.3.5 防火墙配置\n\n宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙\n\n```bash\n# 关闭防火墙\nsystemctl stop firewalld.service \n# 查看防火墙的状态\nfirewall-cmd --state \n# 禁止firewall开机启动\nsystemctl disable firewalld.service\n```\n\n或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：\n\n- `nameserver` 默认使用 9876 端口\n- `master` 默认使用 10911 端口\n- `slave` 默认使用11011 端口\n\n执行以下命令：\n\n```bash\n# 开放name server默认端口\nfirewall-cmd --remove-port=9876/tcp --permanent\n# 开放master默认端口\nfirewall-cmd --remove-port=10911/tcp --permanent\n# 开放slave默认端口 (当前集群模式可不开启)\nfirewall-cmd --remove-port=11011/tcp --permanent \n# 重启防火墙\nfirewall-cmd --reload\n```\n\n### 3.3.6 环境变量配置\n\n```bash\nvim /etc/profile\n```\n\n在profile文件的末尾加入如下命令\n\n```bash\n#set rocketmq\nROCKETMQ_HOME=/usr/local/rocketmq/rocketmq-all-4.4.0-bin-release\nPATH=$PATH:$ROCKETMQ_HOME/bin\nexport ROCKETMQ_HOME PATH\n```\n\n输入:wq! 保存并退出， 并使得配置立刻生效：\n\n```bash\nsource /etc/profile\n```\n\n### 3.3.7 创建消息存储路径\n\n```bash\nmkdir /usr/local/rocketmq/store\nmkdir /usr/local/rocketmq/store/commitlog\nmkdir /usr/local/rocketmq/store/consumequeue\nmkdir /usr/local/rocketmq/store/index\n```\n\n### 3.3.8 broker配置文件\n\n#### 1）master1\n\n服务器：192.168.25.135\n\n```sh\nvi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a.properties\n```\n\n修改配置如下：\n\n```bash\n#所属集群名字\nbrokerClusterName=rocketmq-cluster\n#broker名字，注意此处不同的配置文件填写的不一样\nbrokerName=broker-a\n#0 表示 Master，>0 表示 Slave\nbrokerId=0\n#nameServer地址，分号分割\nnamesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876\n#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数\ndefaultTopicQueueNums=4\n#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭\nautoCreateTopicEnable=true\n#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭\nautoCreateSubscriptionGroup=true\n#Broker 对外服务的监听端口\nlistenPort=10911\n#删除文件时间点，默认凌晨 4点\ndeleteWhen=04\n#文件保留时间，默认 48 小时\nfileReservedTime=120\n#commitLog每个文件的大小默认1G\nmapedFileSizeCommitLog=1073741824\n#ConsumeQueue每个文件默认存30W条，根据业务情况调整\nmapedFileSizeConsumeQueue=300000\n#destroyMapedFileIntervalForcibly=120000\n#redeleteHangedFileInterval=120000\n#检测物理文件磁盘空间\ndiskMaxUsedSpaceRatio=88\n#存储路径\nstorePathRootDir=/usr/local/rocketmq/store\n#commitLog 存储路径\nstorePathCommitLog=/usr/local/rocketmq/store/commitlog\n#消费队列存储路径存储路径\nstorePathConsumeQueue=/usr/local/rocketmq/store/consumequeue\n#消息索引存储路径\nstorePathIndex=/usr/local/rocketmq/store/index\n#checkpoint 文件存储路径\nstoreCheckpoint=/usr/local/rocketmq/store/checkpoint\n#abort 文件存储路径\nabortFile=/usr/local/rocketmq/store/abort\n#限制的消息大小\nmaxMessageSize=65536\n#flushCommitLogLeastPages=4\n#flushConsumeQueueLeastPages=2\n#flushCommitLogThoroughInterval=10000\n#flushConsumeQueueThoroughInterval=60000\n#Broker 的角色\n#- ASYNC_MASTER 异步复制Master\n#- SYNC_MASTER 同步双写Master\n#- SLAVE\nbrokerRole=SYNC_MASTER\n#刷盘方式\n#- ASYNC_FLUSH 异步刷盘\n#- SYNC_FLUSH 同步刷盘\nflushDiskType=SYNC_FLUSH\n#checkTransactionMessageEnable=false\n#发消息线程池数量\n#sendMessageThreadPoolNums=128\n#拉消息线程池数量\n#pullMessageThreadPoolNums=128\n```\n\n#### 2）slave2\n\n服务器：192.168.25.135\n\n```sh\nvi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b-s.properties\n```\n\n修改配置如下：\n\n```bash\n#所属集群名字\nbrokerClusterName=rocketmq-cluster\n#broker名字，注意此处不同的配置文件填写的不一样\nbrokerName=broker-b\n#0 表示 Master，>0 表示 Slave\nbrokerId=1\n#nameServer地址，分号分割\nnamesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876\n#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数\ndefaultTopicQueueNums=4\n#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭\nautoCreateTopicEnable=true\n#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭\nautoCreateSubscriptionGroup=true\n#Broker 对外服务的监听端口\nlistenPort=11011\n#删除文件时间点，默认凌晨 4点\ndeleteWhen=04\n#文件保留时间，默认 48 小时\nfileReservedTime=120\n#commitLog每个文件的大小默认1G\nmapedFileSizeCommitLog=1073741824\n#ConsumeQueue每个文件默认存30W条，根据业务情况调整\nmapedFileSizeConsumeQueue=300000\n#destroyMapedFileIntervalForcibly=120000\n#redeleteHangedFileInterval=120000\n#检测物理文件磁盘空间\ndiskMaxUsedSpaceRatio=88\n#存储路径\nstorePathRootDir=/usr/local/rocketmq/store\n#commitLog 存储路径\nstorePathCommitLog=/usr/local/rocketmq/store/commitlog\n#消费队列存储路径存储路径\nstorePathConsumeQueue=/usr/local/rocketmq/store/consumequeue\n#消息索引存储路径\nstorePathIndex=/usr/local/rocketmq/store/index\n#checkpoint 文件存储路径\nstoreCheckpoint=/usr/local/rocketmq/store/checkpoint\n#abort 文件存储路径\nabortFile=/usr/local/rocketmq/store/abort\n#限制的消息大小\nmaxMessageSize=65536\n#flushCommitLogLeastPages=4\n#flushConsumeQueueLeastPages=2\n#flushCommitLogThoroughInterval=10000\n#flushConsumeQueueThoroughInterval=60000\n#Broker 的角色\n#- ASYNC_MASTER 异步复制Master\n#- SYNC_MASTER 同步双写Master\n#- SLAVE\nbrokerRole=SLAVE\n#刷盘方式\n#- ASYNC_FLUSH 异步刷盘\n#- SYNC_FLUSH 同步刷盘\nflushDiskType=ASYNC_FLUSH\n#checkTransactionMessageEnable=false\n#发消息线程池数量\n#sendMessageThreadPoolNums=128\n#拉消息线程池数量\n#pullMessageThreadPoolNums=128\n```\n\n#### 3）master2\n\n服务器：192.168.25.138\n\n```sh\nvi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b.properties\n```\n\n修改配置如下：\n\n```bash\n#所属集群名字\nbrokerClusterName=rocketmq-cluster\n#broker名字，注意此处不同的配置文件填写的不一样\nbrokerName=broker-b\n#0 表示 Master，>0 表示 Slave\nbrokerId=0\n#nameServer地址，分号分割\nnamesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876\n#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数\ndefaultTopicQueueNums=4\n#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭\nautoCreateTopicEnable=true\n#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭\nautoCreateSubscriptionGroup=true\n#Broker 对外服务的监听端口\nlistenPort=10911\n#删除文件时间点，默认凌晨 4点\ndeleteWhen=04\n#文件保留时间，默认 48 小时\nfileReservedTime=120\n#commitLog每个文件的大小默认1G\nmapedFileSizeCommitLog=1073741824\n#ConsumeQueue每个文件默认存30W条，根据业务情况调整\nmapedFileSizeConsumeQueue=300000\n#destroyMapedFileIntervalForcibly=120000\n#redeleteHangedFileInterval=120000\n#检测物理文件磁盘空间\ndiskMaxUsedSpaceRatio=88\n#存储路径\nstorePathRootDir=/usr/local/rocketmq/store\n#commitLog 存储路径\nstorePathCommitLog=/usr/local/rocketmq/store/commitlog\n#消费队列存储路径存储路径\nstorePathConsumeQueue=/usr/local/rocketmq/store/consumequeue\n#消息索引存储路径\nstorePathIndex=/usr/local/rocketmq/store/index\n#checkpoint 文件存储路径\nstoreCheckpoint=/usr/local/rocketmq/store/checkpoint\n#abort 文件存储路径\nabortFile=/usr/local/rocketmq/store/abort\n#限制的消息大小\nmaxMessageSize=65536\n#flushCommitLogLeastPages=4\n#flushConsumeQueueLeastPages=2\n#flushCommitLogThoroughInterval=10000\n#flushConsumeQueueThoroughInterval=60000\n#Broker 的角色\n#- ASYNC_MASTER 异步复制Master\n#- SYNC_MASTER 同步双写Master\n#- SLAVE\nbrokerRole=SYNC_MASTER\n#刷盘方式\n#- ASYNC_FLUSH 异步刷盘\n#- SYNC_FLUSH 同步刷盘\nflushDiskType=SYNC_FLUSH\n#checkTransactionMessageEnable=false\n#发消息线程池数量\n#sendMessageThreadPoolNums=128\n#拉消息线程池数量\n#pullMessageThreadPoolNums=128\n```\n\n#### 4）slave1\n\n服务器：192.168.25.138\n\n```sh\nvi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a-s.properties\n```\n\n修改配置如下：\n\n```bash\n#所属集群名字\nbrokerClusterName=rocketmq-cluster\n#broker名字，注意此处不同的配置文件填写的不一样\nbrokerName=broker-a\n#0 表示 Master，>0 表示 Slave\nbrokerId=1\n#nameServer地址，分号分割\nnamesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876\n#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数\ndefaultTopicQueueNums=4\n#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭\nautoCreateTopicEnable=true\n#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭\nautoCreateSubscriptionGroup=true\n#Broker 对外服务的监听端口\nlistenPort=11011\n#删除文件时间点，默认凌晨 4点\ndeleteWhen=04\n#文件保留时间，默认 48 小时\nfileReservedTime=120\n#commitLog每个文件的大小默认1G\nmapedFileSizeCommitLog=1073741824\n#ConsumeQueue每个文件默认存30W条，根据业务情况调整\nmapedFileSizeConsumeQueue=300000\n#destroyMapedFileIntervalForcibly=120000\n#redeleteHangedFileInterval=120000\n#检测物理文件磁盘空间\ndiskMaxUsedSpaceRatio=88\n#存储路径\nstorePathRootDir=/usr/local/rocketmq/store\n#commitLog 存储路径\nstorePathCommitLog=/usr/local/rocketmq/store/commitlog\n#消费队列存储路径存储路径\nstorePathConsumeQueue=/usr/local/rocketmq/store/consumequeue\n#消息索引存储路径\nstorePathIndex=/usr/local/rocketmq/store/index\n#checkpoint 文件存储路径\nstoreCheckpoint=/usr/local/rocketmq/store/checkpoint\n#abort 文件存储路径\nabortFile=/usr/local/rocketmq/store/abort\n#限制的消息大小\nmaxMessageSize=65536\n#flushCommitLogLeastPages=4\n#flushConsumeQueueLeastPages=2\n#flushCommitLogThoroughInterval=10000\n#flushConsumeQueueThoroughInterval=60000\n#Broker 的角色\n#- ASYNC_MASTER 异步复制Master\n#- SYNC_MASTER 同步双写Master\n#- SLAVE\nbrokerRole=SLAVE\n#刷盘方式\n#- ASYNC_FLUSH 异步刷盘\n#- SYNC_FLUSH 同步刷盘\nflushDiskType=ASYNC_FLUSH\n#checkTransactionMessageEnable=false\n#发消息线程池数量\n#sendMessageThreadPoolNums=128\n#拉消息线程池数量\n#pullMessageThreadPoolNums=128\n```\n\n### 3.3.9 修改启动脚本文件\n\n#### 1）runbroker.sh\n\n```sh\nvi /usr/local/rocketmq/bin/runbroker.sh\n```\n\n需要根据内存大小进行适当的对JVM参数进行调整：\n\n```bash\n#===================================================\n# 开发环境配置 JVM Configuration\nJAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m\"\n```\n\n#### 2）runserver.sh\n\n```sh\nvim /usr/local/rocketmq/bin/runserver.sh\n```\n\n```bash\nJAVA_OPT=\"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"\n```\n\n### 3.3.10 服务启动\n\n#### 1）启动NameServe集群\n\n分别在192.168.25.135和192.168.25.138启动NameServer\n\n```bash\ncd /usr/local/rocketmq/bin\nnohup sh mqnamesrv &\n```\n\n#### 2）启动Broker集群\n\n- 在192.168.25.135上启动master1和slave2\n\nmaster1：\n\n```bash\ncd /usr/local/rocketmq/bin\nnohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-syncbroker-a.properties &\n```\n\nslave2：\n\n```sh\ncd /usr/local/rocketmq/bin\nnohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-b-s.properties &\n```\n\n- 在192.168.25.138上启动master2和slave2\n\nmaster2\n\n```sh\ncd /usr/local/rocketmq/bin\nnohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-b.properties &\n```\n\nslave1\n\n```sh\ncd /usr/local/rocketmq/bin\nnohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-a-s.properties &\n```\n\n### 3.3.11 查看进程状态\n\n启动后通过JPS查看启动进程\n\n![](img/jps1.png)\n\n### 3.3.12 查看日志\n\n```sh\n# 查看nameServer日志\ntail -500f ~/logs/rocketmqlogs/namesrv.log\n# 查看broker日志\ntail -500f ~/logs/rocketmqlogs/broker.log\n```\n\n## 3.4 mqadmin管理工具\n\n### 3.4.1 使用方式\n\n进入RocketMQ安装位置，在bin目录下执行```./mqadmin {command} {args}``` \n\n### 3.4.2 命令介绍\n\n#### 1）Topic相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n <tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"8\" width=\"163\">updateTopic</td>\n  <td rowspan=\"8\" width=\"135\">创建更新Topic配置</td>\n  <td width=\"149\">-b</td>\n  <td width=\"159\">Broker 地址，表示 topic 所在\n  Broker，只支持单台Broker，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-c</td>\n  <td width=\"159\">cluster 名称，表示 topic 所在集群（集群可通过\n  clusterList 查询）</td>\n </tr>\n <tr>\n  <td width=\"149\">-h-</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-p</td>\n  <td width=\"159\">指定新topic的读写权限( W=2|R=4|WR=6 )</td>\n </tr>\n <tr>\n  <td width=\"149\">-r</td>\n  <td width=\"159\">可读队列数（默认为 8）</td>\n </tr>\n <tr>\n  <td width=\"149\">-w</td>\n  <td width=\"159\">可写队列数（默认为 8）</td>\n </tr>\n <tr>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称（名称只能使用字符\n  ^[a-zA-Z0-9_-]+$ ）</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"163\">deleteTopic</td>\n  <td rowspan=\"4\" width=\"135\">删除Topic</td>\n  <td width=\"149\">-c</td>\n  <td width=\"159\">cluster 名称，表示删除某集群下的某个 topic （集群\n  可通过 clusterList 查询）</td>\n </tr>\n <tr>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称（名称只能使用字符\n  ^[a-zA-Z0-9_-]+$ ）</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"163\">topicList</td>\n  <td rowspan=\"3\" width=\"135\">查看 Topic 列表信息</td>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-c</td>\n  <td width=\"159\">不配置-c只返回topic列表，增加-c返回clusterName,\n  topic, consumerGroup信息，即topic的所属集群和订阅关系，没有参数</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"163\">topicRoute</td>\n  <td rowspan=\"3\" width=\"135\">查看 Topic 路由信息</td>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称</td>\n </tr>\n <tr>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"163\">topicStatus</td>\n  <td rowspan=\"3\" width=\"135\">查看 Topic 消息队列offset</td>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称</td>\n </tr>\n <tr>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"163\">topicClusterList</td>\n  <td rowspan=\"3\" width=\"135\">查看 Topic 所在集群列表</td>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称</td>\n </tr>\n <tr>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"6\" width=\"163\">updateTopicPerm</td>\n  <td rowspan=\"6\" width=\"135\">更新 Topic 读写权限</td>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称</td>\n </tr>\n <tr>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-b</td>\n  <td width=\"159\">Broker 地址，表示 topic 所在\n  Broker，只支持单台Broker，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-p</td>\n  <td width=\"159\">指定新 topic 的读写权限( W=2|R=4|WR=6 )</td>\n </tr>\n <tr>\n  <td width=\"149\">-c</td>\n  <td width=\"159\">cluster 名称，表示 topic 所在集群（集群可通过\n  clusterList 查询），-b优先，如果没有-b，则对集群中所有Broker执行命令</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"163\">updateOrderConf</td>\n  <td rowspan=\"5\" width=\"135\">从NameServer上创建、删除、获取特定命名空间的kv配置，目前还未启用</td>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic，键</td>\n </tr>\n <tr>\n  <td width=\"149\">-v</td>\n  <td width=\"159\">orderConf，值</td>\n </tr>\n <tr>\n  <td width=\"149\">-m</td>\n  <td width=\"159\">method，可选get、put、delete</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"163\">allocateMQ</td>\n  <td rowspan=\"4\" width=\"135\">以平均负载算法计算消费者列表负载消息队列的负载结果</td>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">topic 名称</td>\n </tr>\n <tr>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-i</td>\n  <td width=\"159\">ipList，用逗号分隔，计算这些ip去负载Topic的消息队列</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"163\">statsAll</td>\n  <td rowspan=\"4\" width=\"135\">打印Topic订阅关系、TPS、积累量、24h读写总量等信息</td>\n  <td width=\"149\">-h</td>\n  <td width=\"159\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"149\">-n</td>\n  <td width=\"159\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"149\">-a</td>\n  <td width=\"159\">是否只打印活跃topic</td>\n </tr>\n <tr>\n  <td width=\"149\">-t</td>\n  <td width=\"159\">指定topic</td>\n </tr>\n</table>\n\n#### 2）集群相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n <tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"177\"><span> </span>clusterList</td>\n  <td rowspan=\"4\" width=\"175\">查看集群信息，集群、BrokerName、BrokerId、TPS等信息</td>\n  <td width=\"177\">-m</td>\n  <td width=\"185\">打印更多信息 (增加打印出如下信息 #InTotalYest,\n\n# OutTotalYest, #InTotalToday ,#OutTotalToday)</td>\n\n </tr>\n <tr>\n  <td width=\"177\">-h</td>\n  <td width=\"185\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"177\">-n</td>\n  <td width=\"185\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"177\">-i</td>\n  <td width=\"185\">打印间隔，单位秒</td>\n </tr>\n <tr>\n  <td rowspan=\"8\" width=\"177\">clusterRT</td>\n  <td rowspan=\"8\" width=\"175\">发送消息检测集群各Broker RT。消息发往${BrokerName} Topic。</td>\n  <td width=\"177\">-a</td>\n  <td width=\"185\">amount，每次探测的总数，RT = 总时间 /\n  amount</td>\n </tr>\n <tr>\n  <td width=\"177\">-s</td>\n  <td width=\"185\">消息大小，单位B</td>\n </tr>\n <tr>\n  <td width=\"177\">-c</td>\n  <td width=\"185\">探测哪个集群</td>\n </tr>\n <tr>\n  <td width=\"177\">-p</td>\n  <td width=\"185\">是否打印格式化日志，以|分割，默认不打印</td>\n </tr>\n <tr>\n  <td width=\"177\">-h</td>\n  <td width=\"185\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"177\">-m</td>\n  <td width=\"185\">所属机房，打印使用</td>\n </tr>\n <tr>\n  <td width=\"177\">-i</td>\n  <td width=\"185\">发送间隔，单位秒</td>\n </tr>\n <tr>\n  <td width=\"177\">-n</td>\n  <td width=\"185\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n</table>\n\n#### 3）Broker相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n <tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"6\" width=\"191\">updateBrokerConfig</td>\n  <td rowspan=\"6\" width=\"87\">更新 Broker 配置文件，会修改Broker.conf</td>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，格式为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">cluster 名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-k</td>\n  <td width=\"87\">key 值</td>\n </tr>\n <tr>\n  <td width=\"87\">-v</td>\n  <td width=\"87\">value 值</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"191\">brokerStatus</td>\n  <td rowspan=\"3\" width=\"87\">查看 Broker 统计信息、运行状态（你想要的信息几乎都在里面）</td>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"6\" width=\"191\">brokerConsumeStats</td>\n  <td rowspan=\"6\" width=\"87\">Broker中各个消费者的消费情况，按Message Queue维度返回Consume\n  Offset，Broker Offset，Diff，TImestamp等信息</td>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">请求超时时间</td>\n </tr>\n <tr>\n  <td width=\"87\">-l</td>\n  <td width=\"87\">diff阈值，超过阈值才打印</td>\n </tr>\n <tr>\n  <td width=\"87\">-o</td>\n  <td width=\"87\">是否为顺序topic，一般为false</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"2\" width=\"191\">getBrokerConfig</td>\n  <td rowspan=\"2\" width=\"87\">获取Broker配置</td>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"191\">wipeWritePerm</td>\n  <td rowspan=\"3\" width=\"87\">从NameServer上清除 Broker写权限</td>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"191\">cleanExpiredCQ</td>\n  <td rowspan=\"4\" width=\"87\">清理Broker上过期的Consume Queue，如果手动减少对列数可能产生过期队列</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">集群名称</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"191\">cleanUnusedTopic</td>\n  <td rowspan=\"4\" width=\"87\">清理Broker上不使用的Topic，从内存中释放Topic的Consume\n  Queue，如果手动删除Topic会产生不使用的Topic</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 地址，地址为ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">集群名称</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"191\">sendMsgStatus</td>\n  <td rowspan=\"5\" width=\"87\">向Broker发消息，返回发送状态和RT</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">BrokerName，注意不同于Broker地址</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">消息大小，单位B</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">发送次数</td>\n </tr>\n</table>\n\n#### 4）消息相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n<tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"87\">queryMsgById</td>\n  <td rowspan=\"3\" width=\"87\">根据offsetMsgId查询msg，如果使用开源控制台，应使用offsetMsgId，此命令还有其他参数，具体作用请阅读QueryMsgByIdSubCommand。</td>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">msgId</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"87\">queryMsgByKey</td>\n  <td rowspan=\"4\" width=\"87\">根据消息 Key 查询消息</td>\n  <td width=\"87\">-k</td>\n  <td width=\"87\">msgKey</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">Topic 名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"6\" width=\"87\">queryMsgByOffset</td>\n  <td rowspan=\"6\" width=\"87\">根据 Offset 查询消息</td>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker 名称，（这里需要注意\n  填写的是 Broker 的名称，不是 Broker 的地址，Broker 名称可以在 clusterList 查到）</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">query 队列 id</td>\n </tr>\n <tr>\n  <td width=\"87\">-o</td>\n  <td width=\"87\">offset 值</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic 名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"6\" width=\"87\">queryMsgByUniqueKey</td>\n  <td rowspan=\"6\" width=\"87\">根据msgId查询，msgId不同于offsetMsgId，区别详见常见运维问题。-g，-d配合使用，查到消息后尝试让特定的消费者消费消息并返回消费结果</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">uniqe msg id</td>\n </tr>\n <tr>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">consumerGroup</td>\n </tr>\n <tr>\n  <td width=\"87\">-d</td>\n  <td width=\"87\">clientId</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"87\">checkMsgSendRT</td>\n  <td rowspan=\"5\" width=\"87\">检测向topic发消息的RT，功能类似clusterRT</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-a</td>\n  <td width=\"87\">探测次数</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">消息大小</td>\n </tr>\n <tr>\n  <td rowspan=\"8\" width=\"87\">sendMessage</td>\n  <td rowspan=\"8\" width=\"87\">发送一条消息，可以根据配置发往特定Message Queue，或普通发送。</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-p</td>\n  <td width=\"87\">body，消息体</td>\n </tr>\n <tr>\n  <td width=\"87\">-k</td>\n  <td width=\"87\">keys</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">tags</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">BrokerName</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">queueId</td>\n </tr>\n <tr>\n  <td rowspan=\"10\" width=\"87\">consumeMessage</td>\n  <td rowspan=\"10\" width=\"87\">消费消息。可以根据offset、开始&amp;结束时间戳、消息队列消费消息，配置不同执行不同消费逻辑，详见ConsumeMessageCommand。</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">BrokerName</td>\n </tr>\n <tr>\n  <td width=\"87\">-o</td>\n  <td width=\"87\">从offset开始消费</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">queueId</td>\n </tr>\n <tr>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者分组</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">开始时间戳，格式详见-h</td>\n </tr>\n <tr>\n  <td width=\"87\">-d</td>\n  <td width=\"87\">结束时间戳</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">消费多少条消息</td>\n </tr>\n <tr>\n  <td rowspan=\"8\" width=\"87\">printMsg</td>\n  <td rowspan=\"8\" width=\"87\">从Broker消费消息并打印，可选时间段</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">字符集，例如UTF-8</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">subExpress，过滤表达式</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">开始时间戳，格式参见-h</td>\n </tr>\n <tr>\n  <td width=\"87\">-e</td>\n  <td width=\"87\">结束时间戳</td>\n </tr>\n <tr>\n  <td width=\"87\">-d</td>\n  <td width=\"87\">是否打印消息体</td>\n </tr>\n <tr>\n  <td rowspan=\"12\" width=\"87\">printMsgByQueue</td>\n  <td rowspan=\"12\" width=\"87\">类似printMsg，但指定Message Queue</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">queueId</td>\n </tr>\n <tr>\n  <td width=\"87\">-a</td>\n  <td width=\"87\">BrokerName</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">字符集，例如UTF-8</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">subExpress，过滤表达式</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">开始时间戳，格式参见-h</td>\n </tr>\n <tr>\n  <td width=\"87\">-e</td>\n  <td width=\"87\">结束时间戳</td>\n </tr>\n <tr>\n  <td width=\"87\">-p</td>\n  <td width=\"87\">是否打印消息</td>\n </tr>\n <tr>\n  <td width=\"87\">-d</td>\n  <td width=\"87\">是否打印消息体</td>\n </tr>\n <tr>\n  <td width=\"87\">-f</td>\n  <td width=\"87\">是否统计tag数量并打印</td>\n </tr>\n <tr>\n  <td rowspan=\"7\" width=\"87\">resetOffsetByTime</td>\n  <td rowspan=\"7\" width=\"87\">按时间戳重置offset，Broker和consumer都会重置</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者分组</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">重置为此时间戳对应的offset</td>\n </tr>\n <tr>\n  <td width=\"87\">-f</td>\n  <td width=\"87\">是否强制重置，如果false，只支持回溯offset，如果true，不管时间戳对应offset与consumeOffset关系</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">是否重置c++客户端offset</td>\n </tr>\n</table>\n\n#### 5）消费者、消费组相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n<tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"87\">consumerProgress</td>\n  <td rowspan=\"4\" width=\"87\">查看订阅组消费状态，可以查看具体的client IP的消息积累量</td>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者所属组名</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">是否打印client IP</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"87\">consumerStatus</td>\n  <td rowspan=\"5\" width=\"87\">查看消费者状态，包括同一个分组中是否都是相同的订阅，分析Process\n  Queue是否堆积，返回消费者jstack结果，内容较多，使用者参见ConsumerStatusSubCommand</td>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">consumer group</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">clientId</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">是否执行jstack</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"87\">getConsumerStatus</td>\n  <td rowspan=\"5\" width=\"87\">获取 Consumer 消费进度</td>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者所属组名</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">查询主题</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">Consumer 客户端 ip</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td rowspan=\"13\" width=\"87\">updateSubGroup</td>\n  <td rowspan=\"13\" width=\"87\">更新或创建订阅关系</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker地址</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">集群名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者分组名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">分组是否允许消费</td>\n </tr>\n <tr>\n  <td width=\"87\">-m</td>\n  <td width=\"87\">是否从最小offset开始消费</td>\n </tr>\n <tr>\n  <td width=\"87\">-d</td>\n  <td width=\"87\">是否是广播模式</td>\n </tr>\n <tr>\n  <td width=\"87\">-q</td>\n  <td width=\"87\">重试队列数量</td>\n </tr>\n <tr>\n  <td width=\"87\">-r</td>\n  <td width=\"87\">最大重试次数</td>\n </tr>\n <tr>\n  <td width=\"87\">-i</td>\n  <td width=\"87\">当slaveReadEnable开启时有效，且还未达到从slave消费时建议从哪个BrokerId消费，可以配置备机id，主动从备机消费</td>\n </tr>\n <tr>\n  <td width=\"87\">-w</td>\n  <td width=\"87\">如果Broker建议从slave消费，配置决定从哪个slave消费，配置BrokerId，例如1</td>\n </tr>\n <tr>\n  <td width=\"87\">-a</td>\n  <td width=\"87\">当消费者数量变化时是否通知其他消费者负载均衡</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"87\">deleteSubGroup</td>\n  <td rowspan=\"5\" width=\"87\">从Broker删除订阅关系</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-b</td>\n  <td width=\"87\">Broker地址</td>\n </tr>\n <tr>\n  <td width=\"87\">-c</td>\n  <td width=\"87\">集群名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者分组名称</td>\n </tr>\n <tr>\n  <td rowspan=\"6\" width=\"87\">cloneGroupOffset</td>\n  <td rowspan=\"6\" width=\"87\">在目标群组中使用源群组的offset</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">源消费者组</td>\n </tr>\n <tr>\n  <td width=\"87\">-d</td>\n  <td width=\"87\">目标消费者组</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">topic名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-o</td>\n  <td width=\"87\">暂未使用</td>\n </tr>\n</table>\n\n#### 6）连接相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n<tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"3\" width=\"87\">consumerConnec tion</td>\n  <td rowspan=\"3\" width=\"87\">查询 Consumer 的网络连接</td>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">消费者所属组名</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"87\">producerConnec tion</td>\n  <td rowspan=\"4\" width=\"87\">查询 Producer 的网络连接</td>\n  <td width=\"87\">-g</td>\n  <td width=\"87\">生产者所属组名</td>\n </tr>\n <tr>\n  <td width=\"87\">-t</td>\n  <td width=\"87\">主题名称</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n</table>\n\n#### 7）NameServer相关\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n<tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"5\" width=\"87\">updateKvConfig</td>\n  <td rowspan=\"5\" width=\"87\">更新NameServer的kv配置，目前还未使用</td>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">命名空间</td>\n </tr>\n <tr>\n  <td width=\"87\">-k</td>\n  <td width=\"87\">key</td>\n </tr>\n <tr>\n  <td width=\"87\">-v</td>\n  <td width=\"87\">value</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"87\">deleteKvConfig</td>\n  <td rowspan=\"4\" width=\"87\">删除NameServer的kv配置</td>\n  <td width=\"87\">-s</td>\n  <td width=\"87\">命名空间</td>\n </tr>\n <tr>\n  <td width=\"87\">-k</td>\n  <td width=\"87\">key</td>\n </tr>\n <tr>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td rowspan=\"2\" width=\"87\">getNamesrvConfig</td>\n  <td rowspan=\"2\" width=\"87\">获取NameServer配置</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td rowspan=\"4\" width=\"87\">updateNamesrvConfig</td>\n  <td rowspan=\"4\" width=\"87\">修改NameServer配置</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n <tr>\n  <td width=\"87\">-k</td>\n  <td width=\"87\">key</td>\n </tr>\n <tr>\n  <td width=\"87\">-v</td>\n  <td width=\"87\">value</td>\n </tr>\n</table>\n\n#### 8）其他\n\n<table border=\"0\" width=\"714\">\n <col width=\"177\">\n <col width=\"175\">\n <col width=\"177\">\n <col width=\"185\">\n<tr>\n  <td width=\"177\">名称</td>\n  <td width=\"175\">含义</td>\n  <td width=\"177\">命令选项</td>\n  <td width=\"185\">说明</td>\n </tr>\n <tr>\n  <td rowspan=\"2\" width=\"87\">startMonitoring</td>\n  <td rowspan=\"2\" width=\"87\">开启监控进程，监控消息误删、重试队列消息数等</td>\n  <td width=\"87\">-n</td>\n  <td width=\"87\">NameServer 服务地址，格式 ip:port</td>\n </tr>\n <tr>\n  <td width=\"87\">-h</td>\n  <td width=\"87\">打印帮助</td>\n </tr>\n</table>\n\n### 3.4.3 注意事项\n\n- 几乎所有命令都需要配置-n表示NameServer地址，格式为ip:port\n- 几乎所有命令都可以通过-h获取帮助\n- 如果既有Broker地址（-b）配置项又有clusterName（-c）配置项，则优先以Broker地址执行命令；如果不配置Broker地址，则对集群中所有主机执行命令\n\n## 3.5 集群监控平台搭建\n\n### 3.5.1 概述\n\n`RocketMQ`有一个对其扩展的开源项目[incubator-rocketmq-externals](https://github.com/apache/rocketmq-externals)，这个项目中有一个子模块叫`rocketmq-console`，这个便是管理控制台项目了，先将[incubator-rocketmq-externals](https://github.com/apache/rocketmq-externals)拉到本地，因为我们需要自己对`rocketmq-console`进行编译打包运行。\n\n![](img/rocketmq-console.png)\n\n### 3.5.2 下载并编译打包\n\n```sh\ngit clone https://github.com/apache/rocketmq-externals\ncd rocketmq-console\nmvn clean package -Dmaven.test.skip=true\n```\n\n注意：打包前在```rocketmq-console```中配置```namesrv```集群地址：\n\n```sh\nrocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876\n```\n\n启动rocketmq-console：\n\n```sh\njava -jar rocketmq-console-ng-1.0.0.jar\n```\n\n启动成功后，我们就可以通过浏览器访问`http://localhost:8080`进入控制台界面了，如下图：\n\n![](img/rocketmq-console2.png)\n\n集群状态：\n\n![](img/rocketmq-console3.png)\n\n# 4. 消息发送样例\n\n- 导入MQ客户端依赖\n\n```xml\n<dependency>\n    <groupId>org.apache.rocketmq</groupId>\n    <artifactId>rocketmq-client</artifactId>\n    <version>4.4.0</version>\n</dependency>\n```\n\n- 消息发送者步骤分析r\n\n```tex\n1.创建消息生产者producer，并制定生产者组名\n2.指定Nameserver地址\n3.启动producer\n4.创建消息对象，指定主题Topic、Tag和消息体\n5.发送消息\n6.关闭生产者producer\n```\n\n- 消息消费者步骤分析\n\n```tex\n1.创建消费者Consumer，制定消费者组名\n2.指定Nameserver地址\n3.订阅主题Topic和Tag\n4.设置回调函数，处理消息\n5.启动消费者consumer\n```\n\n## 4.1 基本样例\n\n### 4.1.1 消息发送\n\n#### 1）发送同步消息\n\n这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。\n\n```java\npublic class SyncProducer {\n	public static void main(String[] args) throws Exception {\n    	// 实例化消息生产者Producer\n        DefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n    	// 设置NameServer的地址\n    	producer.setNamesrvAddr(\"localhost:9876\");\n    	// 启动Producer实例\n        producer.start();\n    	for (int i = 0; i < 100; i++) {\n    	    // 创建消息，并指定Topic，Tag和消息体\n    	    Message msg = new Message(\"TopicTest\" /* Topic */,\n        	\"TagA\" /* Tag */,\n        	(\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */\n        	);\n        	// 发送消息到一个Broker\n            SendResult sendResult = producer.send(msg);\n            // 通过sendResult返回消息是否成功送达\n            System.out.printf(\"%s%n\", sendResult);\n    	}\n    	// 如果不再发送消息，关闭Producer实例。\n    	producer.shutdown();\n    }\n}\n```\n\n#### 2）发送异步消息\n\n异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。\n\n```java\npublic class AsyncProducer {\n	public static void main(String[] args) throws Exception {\n    	// 实例化消息生产者Producer\n        DefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n    	// 设置NameServer的地址\n        producer.setNamesrvAddr(\"localhost:9876\");\n    	// 启动Producer实例\n        producer.start();\n        producer.setRetryTimesWhenSendAsyncFailed(0);\n    	for (int i = 0; i < 100; i++) {\n                final int index = i;\n            	// 创建消息，并指定Topic，Tag和消息体\n                Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n                // SendCallback接收异步返回结果的回调\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        System.out.printf(\"%-10d OK %s %n\", index,\n                            sendResult.getMsgId());\n                    }\n                    @Override\n                    public void onException(Throwable e) {\n      	              System.out.printf(\"%-10d Exception %s %n\", index, e);\n      	              e.printStackTrace();\n                    }\n            	});\n    	}\n    	// 如果不再发送消息，关闭Producer实例。\n    	producer.shutdown();\n    }\n}\n```\n\n#### 3）单向发送消息\n\n这种方式主要用在不特别关心发送结果的场景，例如日志发送。\n\n```java\npublic class OnewayProducer {\n	public static void main(String[] args) throws Exception{\n    	// 实例化消息生产者Producer\n        DefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n    	// 设置NameServer的地址\n        producer.setNamesrvAddr(\"localhost:9876\");\n    	// 启动Producer实例\n        producer.start();\n    	for (int i = 0; i < 100; i++) {\n        	// 创建消息，并指定Topic，Tag和消息体\n        	Message msg = new Message(\"TopicTest\" /* Topic */,\n                \"TagA\" /* Tag */,\n                (\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */\n        	);\n        	// 发送单向消息，没有任何返回结果\n        	producer.sendOneway(msg);\n\n    	}\n    	// 如果不再发送消息，关闭Producer实例。\n    	producer.shutdown();\n    }\n}\n```\n\n### 4.1.2 消费消息\n\n#### 1）负载均衡模式\n\n消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 实例化消息生产者,指定组名\n    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"group1\");\n    // 指定Namesrv地址信息.\n    consumer.setNamesrvAddr(\"localhost:9876\");\n    // 订阅Topic\n    consumer.subscribe(\"Test\", \"*\");\n    //负载均衡模式消费\n    consumer.setMessageModel(MessageModel.CLUSTERING);\n    // 注册回调函数，处理消息\n    consumer.registerMessageListener(new MessageListenerConcurrently() {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                        ConsumeConcurrentlyContext context) {\n            System.out.printf(\"%s Receive New Messages: %s %n\", \n                              Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    });\n    //启动消息者\n    consumer.start();\n    System.out.printf(\"Consumer Started.%n\");\n}\n```\n\n#### 2）广播模式\n\n消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 实例化消息生产者,指定组名\n    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"group1\");\n    // 指定Namesrv地址信息.\n    consumer.setNamesrvAddr(\"localhost:9876\");\n    // 订阅Topic\n    consumer.subscribe(\"Test\", \"*\");\n    //广播模式消费\n    consumer.setMessageModel(MessageModel.BROADCASTING);\n    // 注册回调函数，处理消息\n    consumer.registerMessageListener(new MessageListenerConcurrently() {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                        ConsumeConcurrentlyContext context) {\n            System.out.printf(\"%s Receive New Messages: %s %n\", \n                              Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    });\n    //启动消息者\n    consumer.start();\n    System.out.printf(\"Consumer Started.%n\");\n}\n```\n\n## 4.2 顺序消息\n\n消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。\n\n顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。\n\n下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。\n\n### 4.2.1 顺序消息生产\n\n```java\n/**\n* Producer，发送顺序消息\n*/\npublic class Producer {\n\n   public static void main(String[] args) throws Exception {\n       DefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n\n       producer.setNamesrvAddr(\"127.0.0.1:9876\");\n\n       producer.start();\n\n       String[] tags = new String[]{\"TagA\", \"TagC\", \"TagD\"};\n\n       // 订单列表\n       List<OrderStep> orderList = new Producer().buildOrders();\n\n       Date date = new Date();\n       SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n       String dateStr = sdf.format(date);\n       for (int i = 0; i < 10; i++) {\n           // 加个时间前缀\n           String body = dateStr + \" Hello RocketMQ \" + orderList.get(i);\n           Message msg = new Message(\"TopicTest\", tags[i % tags.length], \"KEY\" + i, body.getBytes());\n\n           SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n               @Override\n               public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                   Long id = (Long) arg;  //根据订单id选择发送queue\n                   long index = id % mqs.size();\n                   return mqs.get((int) index);\n               }\n           }, orderList.get(i).getOrderId());//订单id\n\n           System.out.println(String.format(\"SendResult status:%s, queueId:%d, body:%s\",\n               sendResult.getSendStatus(),\n               sendResult.getMessageQueue().getQueueId(),\n               body));\n       }\n\n       producer.shutdown();\n   }\n\n   /**\n    * 订单的步骤\n    */\n   private static class OrderStep {\n       private long orderId;\n       private String desc;\n\n       public long getOrderId() {\n           return orderId;\n       }\n\n       public void setOrderId(long orderId) {\n           this.orderId = orderId;\n       }\n\n       public String getDesc() {\n           return desc;\n       }\n\n       public void setDesc(String desc) {\n           this.desc = desc;\n       }\n\n       @Override\n       public String toString() {\n           return \"OrderStep{\" +\n               \"orderId=\" + orderId +\n               \", desc=\'\" + desc + \'\\\'\' +\n               \'}\';\n       }\n   }\n\n   /**\n    * 生成模拟订单数据\n    */\n   private List<OrderStep> buildOrders() {\n       List<OrderStep> orderList = new ArrayList<OrderStep>();\n\n       OrderStep orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"推送\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n\n       return orderList;\n   }\n}\n```\n\n### 4.2.2 顺序消费消息\n\n```java\n/**\n* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）\n*/\npublic class ConsumerInOrder {\n\n   public static void main(String[] args) throws Exception {\n       DefaultMQPushConsumer consumer = new \n           DefaultMQPushConsumer(\"please_rename_unique_group_name_3\");\n       consumer.setNamesrvAddr(\"127.0.0.1:9876\");\n       /**\n        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费<br>\n        * 如果非第一次启动，那么按照上次消费的位置继续消费\n        */\n       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n       consumer.subscribe(\"TopicTest\", \"TagA || TagC || TagD\");\n\n       consumer.registerMessageListener(new MessageListenerOrderly() {\n\n           Random random = new Random();\n\n           @Override\n           public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n               context.setAutoCommit(true);\n               for (MessageExt msg : msgs) {\n                   // 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序\n                   System.out.println(\"consumeThread=\" + Thread.currentThread().getName() + \"queueId=\" + msg.getQueueId() + \", content:\" + new String(msg.getBody()));\n               }\n\n               try {\n                   //模拟业务逻辑处理中...\n                   TimeUnit.SECONDS.sleep(random.nextInt(10));\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n               return ConsumeOrderlyStatus.SUCCESS;\n           }\n       });\n\n       consumer.start();\n\n       System.out.println(\"Consumer Started.\");\n   }\n}\n```\n\n## 4.3 延时消息\n\n比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。\n\n### 4.3.1 启动消息消费者\n\n```java\npublic class ScheduledMessageConsumer {\n   public static void main(String[] args) throws Exception {\n      // 实例化消费者\n      DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"ExampleConsumer\");\n      // 订阅Topics\n      consumer.subscribe(\"TestTopic\", \"*\");\n      // 注册消息监听者\n      consumer.registerMessageListener(new MessageListenerConcurrently() {\n          @Override\n          public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n              for (MessageExt message : messages) {\n                  // Print approximate delay time period\n                  System.out.println(\"Receive message[msgId=\" + message.getMsgId() + \"] \" + (System.currentTimeMillis() - message.getStoreTimestamp()) + \"ms later\");\n              }\n              return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n          }\n      });\n      // 启动消费者\n      consumer.start();\n  }\n}\n```\n\n### 4.3.2 发送延时消息\n\n```java\npublic class ScheduledMessageProducer {\n   public static void main(String[] args) throws Exception {\n      // 实例化一个生产者来产生延时消息\n      DefaultMQProducer producer = new DefaultMQProducer(\"ExampleProducerGroup\");\n      // 启动生产者\n      producer.start();\n      int totalMessagesToSend = 100;\n      for (int i = 0; i < totalMessagesToSend; i++) {\n          Message message = new Message(\"TestTopic\", (\"Hello scheduled message \" + i).getBytes());\n          // 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)\n          message.setDelayTimeLevel(3);\n          // 发送消息\n          producer.send(message);\n      }\n       // 关闭生产者\n      producer.shutdown();\n  }\n}\n```\n\n### 4.3.3 验证\n\n您将会看到消息的消费比存储时间晚10秒\n\n### 4.3.4 使用限制\n\n```java\n// org/apache/rocketmq/store/config/MessageStoreConfig.java\nprivate String messageDelayLevel = \"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\";\n```\n\n现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18\n\n## 4.4 批量消息\n\n批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。\n\n### 4.4.1 发送批量消息\n\n如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：\n\n```java\nString topic = \"BatchTest\";\nList<Message> messages = new ArrayList<>();\nmessages.add(new Message(topic, \"TagA\", \"OrderID001\", \"Hello world 0\".getBytes()));\nmessages.add(new Message(topic, \"TagA\", \"OrderID002\", \"Hello world 1\".getBytes()));\nmessages.add(new Message(topic, \"TagA\", \"OrderID003\", \"Hello world 2\".getBytes()));\ntry {\n   producer.send(messages);\n} catch (Exception e) {\n   e.printStackTrace();\n   //处理error\n}\n```\n\n如果消息的总长度可能大于4MB时，这时候最好把消息进行分割\n\n```java\npublic class ListSplitter implements Iterator<List<Message>> {\n   private final int SIZE_LIMIT = 1024 * 1024 * 4;\n   private final List<Message> messages;\n   private int currIndex;\n   public ListSplitter(List<Message> messages) {\n           this.messages = messages;\n   }\n    @Override \n    public boolean hasNext() {\n       return currIndex < messages.size();\n   }\n   	@Override \n    public List<Message> next() {\n       int nextIndex = currIndex;\n       int totalSize = 0;\n       for (; nextIndex < messages.size(); nextIndex++) {\n           Message message = messages.get(nextIndex);\n           int tmpSize = message.getTopic().length() + message.getBody().length;\n           Map<String, String> properties = message.getProperties();\n           for (Map.Entry<String, String> entry : properties.entrySet()) {\n               tmpSize += entry.getKey().length() + entry.getValue().length();\n           }\n           tmpSize = tmpSize + 20; // 增加日志的开销20字节\n           if (tmpSize > SIZE_LIMIT) {\n               //单个消息超过了最大的限制\n               //忽略,否则会阻塞分裂的进程\n               if (nextIndex - currIndex == 0) {\n                  //假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环\n                  nextIndex++;\n               }\n               break;\n           }\n           if (tmpSize + totalSize > SIZE_LIMIT) {\n               break;\n           } else {\n               totalSize += tmpSize;\n           }\n\n       }\n       List<Message> subList = messages.subList(currIndex, nextIndex);\n       currIndex = nextIndex;\n       return subList;\n   }\n}\n//把大的消息分裂成若干个小的消息\nListSplitter splitter = new ListSplitter(messages);\nwhile (splitter.hasNext()) {\n  try {\n      List<Message>  listItem = splitter.next();\n      producer.send(listItem);\n  } catch (Exception e) {\n      e.printStackTrace();\n      //处理error\n  }\n}\n```\n\n## 4.5 过滤消息\n\n在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：\n\n```java\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"CID_EXAMPLE\");\nconsumer.subscribe(\"TOPIC\", \"TAGA || TAGB || TAGC\");\n```\n\n消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：\n\n```te\n------------\n| message  |\n|----------|  a > 5 AND b = \'abc\'\n| a = 10   |  --------------------> Gotten\n| b = \'abc\'|\n| c = true |\n------------\n------------\n| message  |\n|----------|   a > 5 AND b = \'abc\'\n| a = 1    |  --------------------> Missed\n| b = \'abc\'|\n| c = true |\n------------\n```\n\n### 4.5.1 SQL基本语法\n\nRocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。\n\n- 数值比较，比如：**>，>=，<，<=，BETWEEN，=；**\n- 字符比较，比如：**=，<>，IN；**\n- **IS NULL** 或者 **IS NOT NULL；**\n- 逻辑符号 **AND，OR，NOT；**\n\n常量支持类型为：\n\n- 数值，比如：**123，3.1415；**\n- 字符，比如：**\'abc\'，必须用单引号包裹起来；**\n- **NULL**，特殊的常量\n- 布尔值，**TRUE** 或 **FALSE**\n\n只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：\n\n```java\npublic void subscribe(finalString topic, final MessageSelector messageSelector)\n```\n\n### 4.5.2 消息生产者\n\n发送消息时，你能通过`putUserProperty`来设置消息的属性\n\n```java\nDefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\nproducer.start();\nMessage msg = new Message(\"TopicTest\",\n   tag,\n   (\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET)\n);\n// 设置一些属性\nmsg.putUserProperty(\"a\", String.valueOf(i));\nSendResult sendResult = producer.send(msg);\n\nproducer.shutdown();\n```\n\n### 4.5.3 消息消费者\n\n用MessageSelector.bySql来使用sql筛选消息\n\n```java\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_4\");\n// 只有订阅的消息有这个属性a, a >=0 and a <= 3\nconsumer.subscribe(\"TopicTest\", MessageSelector.bySql(\"a between 0 and 3\");\nconsumer.registerMessageListener(new MessageListenerConcurrently() {\n   @Override\n   public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n       return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n   }\n});\nconsumer.start();\n```\n\n## 4.6 事务消息\n\n### 4.6.1 流程分析\n\n![](img/事务消息.png)\n\n\n\n上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。\n\n#### 1）事务消息发送及提交\n\n(1) 发送消息（half消息）。\n\n(2) 服务端响应消息写入结果。\n\n(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。\n\n(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）\n\n#### 2）事务补偿\n\n(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”\n\n(2) Producer收到回查消息，检查回查消息对应的本地事务的状态\n\n(3) 根据本地事务状态，重新Commit或者Rollback\n\n其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。\n\n#### 3）事务消息状态\n\n事务消息共有三种状态，提交状态、回滚状态、中间状态：\n\n- TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。\n- TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。\n- TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。\n\n### 4.6.1 发送事务消息\n\n#### 1) 创建事务性生产者\n\n使用 `TransactionMQProducer`类创建生产者，并指定唯一的 `ProducerGroup`，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。\n\n```java\npublic class Producer {\n    public static void main(String[] args) throws MQClientException, InterruptedException {\n        //创建事务监听器\n        TransactionListener transactionListener = new TransactionListenerImpl();\n        //创建消息生产者\n        TransactionMQProducer producer = new TransactionMQProducer(\"group6\");\n        producer.setNamesrvAddr(\"192.168.25.135:9876;192.168.25.138:9876\");\n        //生产者这是监听器\n        producer.setTransactionListener(transactionListener);\n        //启动消息生产者\n        producer.start();\n        String[] tags = new String[]{\"TagA\", \"TagB\", \"TagC\"};\n        for (int i = 0; i < 3; i++) {\n            try {\n                Message msg = new Message(\"TransactionTopic\", tags[i % tags.length], \"KEY\" + i,\n                        (\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET));\n                SendResult sendResult = producer.sendMessageInTransaction(msg, null);\n                System.out.printf(\"%s%n\", sendResult);\n                TimeUnit.SECONDS.sleep(1);\n            } catch (MQClientException | UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        //producer.shutdown();\n    }\n}\n```\n\n#### 2）实现事务的监听接口\n\n当发送半消息成功时，我们使用 `executeLocalTransaction` 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。`checkLocalTranscation` 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。\n\n```java\npublic class TransactionListenerImpl implements TransactionListener {\n\n    @Override\n    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {\n        System.out.println(\"执行本地事务\");\n        if (StringUtils.equals(\"TagA\", msg.getTags())) {\n            return LocalTransactionState.COMMIT_MESSAGE;\n        } else if (StringUtils.equals(\"TagB\", msg.getTags())) {\n            return LocalTransactionState.ROLLBACK_MESSAGE;\n        } else {\n            return LocalTransactionState.UNKNOW;\n        }\n\n    }\n\n    @Override\n    public LocalTransactionState checkLocalTransaction(MessageExt msg) {\n        System.out.println(\"MQ检查消息Tag【\"+msg.getTags()+\"】的本地事务执行结果\");\n        return LocalTransactionState.COMMIT_MESSAGE;\n    }\n}\n```\n\n### 4.6.2 使用限制\n\n1. 事务消息不支持延时消息和批量消息。\n2. 为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 `transactionCheckMax`参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = `transactionCheckMax` ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 `AbstractTransactionCheckListener` 类来修改这个行为。\n3. 事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 `transactionMsgTimeout` 参数。\n4. 事务性消息可能不止一次被检查或消费。\n5. 提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。\n6. 事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。', '2020-05-13 11:41:12', '2020-05-13 11:41:12');
INSERT INTO `note` VALUES ('fd08a6cd5ec16cd972287089806fae28', '20154001', '第二个', '# 第二个', '2020-05-13 11:30:06', '2020-05-13 11:37:13');
INSERT INTO `note` VALUES ('fd9a0a13700e54889d1654c6d9889b56', '20154001', '第一个', '# 第一个', '2020-05-13 11:29:39', '2020-05-13 11:37:10');

-- ----------------------------
-- Table structure for `package`
-- ----------------------------
DROP TABLE IF EXISTS `package`;
CREATE TABLE `package` (
  `packageId` varchar(50) NOT NULL,
  `studentId` varchar(20) NOT NULL,
  `questionType` varchar(10) NOT NULL,
  `questionId` varchar(10) NOT NULL,
  PRIMARY KEY (`packageId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of package
-- ----------------------------
INSERT INTO `package` VALUES ('2a659b33f111b7a8e4a2b8f8348c3b16', '20154001', '选择题', '10028');
INSERT INTO `package` VALUES ('677dba18755a84c3fe0898b68a3a2323', '20154001', '选择题', '10001');
INSERT INTO `package` VALUES ('6955e5c8bfbaec520d7ab4109364238f', '20154001', '选择题', '10024');
INSERT INTO `package` VALUES ('6e0a4151d7c8aa04d5d33dcb175357ed', '20154001', '判断题', '10010');
INSERT INTO `package` VALUES ('90d651a72c3bedc5e67a70876a20620d', '20154001', '判断题', '10003');
INSERT INTO `package` VALUES ('b46f9007383f2235366fdcd2c3eca7a8', '20154001', '填空题', '10005');
INSERT INTO `package` VALUES ('bf3b9f9f1fdcceb0a754f947d15ec5f1', '20154001', '判断题', '10008');
INSERT INTO `package` VALUES ('c5e06fc8e6100fa42783fd58df9c7cc7', '20154001', '选择题', '10020');
INSERT INTO `package` VALUES ('caaec351e433bea26cd4de5f0c9e040a', '20154001', '填空题', '10001');
INSERT INTO `package` VALUES ('cdc6b79e1b682f0ece1b1edc214055f3', '20154001', '选择题', '10026');
INSERT INTO `package` VALUES ('d7d4f85f5ea6805e6532dcaa5c218fb0', '20154001', '判断题', '10012');
INSERT INTO `package` VALUES ('e5c3bece313cc517e297b5d7e7b69018', '20154001', '判断题', '10002');

-- ----------------------------
-- Table structure for `paper_manage`
-- ----------------------------
DROP TABLE IF EXISTS `paper_manage`;
CREATE TABLE `paper_manage` (
  `paperId` int(9) DEFAULT NULL COMMENT '试卷编号',
  `questionType` int(1) DEFAULT NULL COMMENT '题目类型',
  `questionId` int(9) DEFAULT NULL COMMENT '题目编号'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='试卷管理表';

-- ----------------------------
-- Records of paper_manage
-- ----------------------------
INSERT INTO `paper_manage` VALUES ('1001', '1', '10001');
INSERT INTO `paper_manage` VALUES ('1001', '1', '10003');
INSERT INTO `paper_manage` VALUES ('1001', '1', '10004');
INSERT INTO `paper_manage` VALUES ('1001', '1', '10000');
INSERT INTO `paper_manage` VALUES ('1001', '1', '10005');
INSERT INTO `paper_manage` VALUES ('1001', '1', '10006');
INSERT INTO `paper_manage` VALUES ('1001', '2', '10000');
INSERT INTO `paper_manage` VALUES ('1001', '2', '10001');
INSERT INTO `paper_manage` VALUES ('1001', '2', '10002');
INSERT INTO `paper_manage` VALUES ('1001', '2', '10003');
INSERT INTO `paper_manage` VALUES ('1001', '2', '10004');
INSERT INTO `paper_manage` VALUES ('1001', '2', '10005');
INSERT INTO `paper_manage` VALUES ('1001', '3', '10001');
INSERT INTO `paper_manage` VALUES ('1001', '3', '10002');
INSERT INTO `paper_manage` VALUES ('1001', '3', '10003');
INSERT INTO `paper_manage` VALUES ('1001', '3', '10004');
INSERT INTO `paper_manage` VALUES ('1001', '3', '10005');
INSERT INTO `paper_manage` VALUES ('1001', '3', '10006');

-- ----------------------------
-- Table structure for `replay`
-- ----------------------------
DROP TABLE IF EXISTS `replay`;
CREATE TABLE `replay` (
  `messageId` int(255) DEFAULT NULL COMMENT '留言编号',
  `replayId` int(9) NOT NULL AUTO_INCREMENT COMMENT '回复编号',
  `replay` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '内容',
  `replayTime` date DEFAULT NULL COMMENT '回复时间',
  PRIMARY KEY (`replayId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='回复表';

-- ----------------------------
-- Records of replay
-- ----------------------------
INSERT INTO `replay` VALUES ('26', '3', '好呀，我来了，你别跑！', '2019-03-18');
INSERT INTO `replay` VALUES ('22', '4', '心疼你2秒钟', '2019-03-18');
INSERT INTO `replay` VALUES ('25', '5', '我也要变强', '2019-03-19');
INSERT INTO `replay` VALUES ('25', '6', '俺也一样', '2019-03-19');
INSERT INTO `replay` VALUES ('21', '7', '既然这样，那就迎男而上吧', '2019-03-19');
INSERT INTO `replay` VALUES ('16', '8', '那条街确实没什么东西可以吃了。。。', '2019-03-19');
INSERT INTO `replay` VALUES ('15', '9', '咸鱼其实还可以吃，而你,emmmm', '2019-03-19');
INSERT INTO `replay` VALUES ('21', '11', '我不怕人多', '2019-03-19');
INSERT INTO `replay` VALUES ('20', '12', '是嘞，还行。', '2019-03-19');
INSERT INTO `replay` VALUES ('26', '13', '我也爱你ε=(´ο｀*)))唉', '2019-03-19');
INSERT INTO `replay` VALUES ('27', '14', '你这个坏孩子', '2019-03-31');
INSERT INTO `replay` VALUES ('33', '18', '是的，今天是周一。', '2019-04-14');
INSERT INTO `replay` VALUES ('34', '19', '1111', '2019-04-16');
INSERT INTO `replay` VALUES ('34', '20', '2222', '2019-04-16');
INSERT INTO `replay` VALUES ('35', '21', '666', '2019-09-05');
INSERT INTO `replay` VALUES ('36', '22', 'asgas ', '2019-11-26');
INSERT INTO `replay` VALUES ('36', '23', 'sagas ', '2019-11-26');

-- ----------------------------
-- Table structure for `score`
-- ----------------------------
DROP TABLE IF EXISTS `score`;
CREATE TABLE `score` (
  `scoreId` int(9) NOT NULL AUTO_INCREMENT COMMENT '分数编号',
  `examCode` int(9) DEFAULT NULL COMMENT '考试编号',
  `studentId` int(9) DEFAULT NULL COMMENT '学号',
  `subject` varchar(20) COLLATE utf8_bin NOT NULL COMMENT '课程名称',
  `ptScore` int(5) DEFAULT NULL COMMENT '平时成绩',
  `etScore` int(5) DEFAULT NULL COMMENT '期末成绩',
  `score` int(5) DEFAULT NULL COMMENT '总成绩',
  `answerDate` varchar(10) COLLATE utf8_bin DEFAULT NULL COMMENT '答题日期',
  PRIMARY KEY (`scoreId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='成绩管理表';

-- ----------------------------
-- Records of score
-- ----------------------------
INSERT INTO `score` VALUES ('4', '20190001', '20154084', '计算机网络', null, '70', null, '2019-04-03');
INSERT INTO `score` VALUES ('14', '20154001', '20154084', '数据库理论', null, '78', null, '2019-04-20');
INSERT INTO `score` VALUES ('15', '20154001', '20154084', '数据库理论', null, '80', null, '2019-04-20');
INSERT INTO `score` VALUES ('16', '20154001', '20154084', '数据库理论', null, '83', null, '2019-04-20');
INSERT INTO `score` VALUES ('17', '20190001', '20154001', '计算机网络', null, '74', null, '2019-04-13');
INSERT INTO `score` VALUES ('18', '20190001', '20154001', '计算机网络', null, '70', null, '2019-04-10');
INSERT INTO `score` VALUES ('19', '20190001', '20155003', '计算机网络', null, '86', null, '2019-04-14');
INSERT INTO `score` VALUES ('20', '20190001', '20155007', '计算机网络', null, '90', null, '2019-04-11');
INSERT INTO `score` VALUES ('21', '20190001', '20155007', '计算机网络', null, '92', null, '2019-04-12');
INSERT INTO `score` VALUES ('22', '20190001', '20155008', '计算机网络', null, '80', null, '2019-04-12');
INSERT INTO `score` VALUES ('23', '20190001', '20155003', '计算机网络', null, '90', null, '2019-04-13');
INSERT INTO `score` VALUES ('24', '20190001', '20155008', '计算机网络', null, '88', null, '2019-04-14');
INSERT INTO `score` VALUES ('27', '20190001', '20154084', '计算机网络', null, '80', null, '2019-04-25');
INSERT INTO `score` VALUES ('30', '20190001', '20154084', '计算机网络', null, '0', null, '2019-04-29');
INSERT INTO `score` VALUES ('31', '20190001', '20154084', '计算机网络', null, '0', null, '2019-09-06');
INSERT INTO `score` VALUES ('32', '20190014', '20154084', 'test001', null, '0', null, '2019-11-27');
INSERT INTO `score` VALUES ('33', '20190001', '20154084', '计算机网络', null, '0', null, '2019-12-09');
INSERT INTO `score` VALUES ('34', '20190001', '20154084', '计算机网络', null, '4', null, '2019-12-09');
INSERT INTO `score` VALUES ('35', '20190001', '20154084', '计算机网络', null, '0', null, '2019-12-09');
INSERT INTO `score` VALUES ('37', '20190001', '20154084', '计算机网络', null, '0', null, '2020-01-11');
INSERT INTO `score` VALUES ('38', '20190001', '20154084', '计算机网络', null, '0', null, '2020-01-11');
INSERT INTO `score` VALUES ('39', '20190001', '20154084', '计算机网络', null, '0', null, '2020-01-11');
INSERT INTO `score` VALUES ('40', '20190001', '20154084', '计算机网络', null, '8', null, '2020-01-11');
INSERT INTO `score` VALUES ('41', '20190001', '20154084', '计算机网络', null, '4', null, '2020-01-11');

-- ----------------------------
-- Table structure for `student`
-- ----------------------------
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student` (
  `studentId` int(9) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `studentName` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '姓名',
  `grade` varchar(4) COLLATE utf8_bin DEFAULT NULL COMMENT '年级',
  `major` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '专业',
  `clazz` varchar(10) COLLATE utf8_bin DEFAULT NULL COMMENT '班级',
  `institute` varchar(30) COLLATE utf8_bin DEFAULT NULL COMMENT '学院',
  `tel` varchar(11) COLLATE utf8_bin DEFAULT NULL COMMENT '电话号码',
  `email` varchar(30) COLLATE utf8_bin DEFAULT NULL COMMENT '电子邮件',
  `pwd` varchar(16) COLLATE utf8_bin DEFAULT NULL COMMENT '密码',
  `cardId` varchar(18) COLLATE utf8_bin DEFAULT NULL COMMENT '身份证号',
  `sex` varchar(2) COLLATE utf8_bin DEFAULT NULL COMMENT '性别',
  `role` varchar(1) COLLATE utf8_bin DEFAULT '2' COMMENT '角色(0管理员，1教师，2学生)',
  PRIMARY KEY (`studentId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=20155013 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='学生信息表';

-- ----------------------------
-- Records of student
-- ----------------------------
INSERT INTO `student` VALUES ('20154001', '小新新', '2018', '计算机科学与技术', '2', '软件工程学院', '13585439532', 'ywh1697479326@qq.com', '123456', '3412312', '男', '2');
INSERT INTO `student` VALUES ('20154084', '臭猪猪', '2018', '计算机科学与技术', '2', '软件工程学院', '13658377857', '13658377857@sina.cn', '123456', '124123124535', '男', '2');
INSERT INTO `student` VALUES ('20155003', '小宝', '2015', '信息工程', '1', '软件工程学院', '15583829425', '15583829425@163.com', '123456', '3242342', '男', '2');
INSERT INTO `student` VALUES ('20155007', '翠花', '2015', '网络工程', '1', '软件工程学院', '18734538457', '18734538457@163.com', '123456', '2423423', '女', '2');
INSERT INTO `student` VALUES ('20155008', '小王', '2015', '信息工程', '2', '软件工程学院', '15523619564', '15523619564@163.com', '123456', '500234199704022353', '男', '2');
INSERT INTO `student` VALUES ('20155010', '小米', '大二', '国际金融贸易', '金融3班', '商学院', '161651', '2116516186', '123456', '4981651651', '男', '2');
INSERT INTO `student` VALUES ('20155011', 'aaaa', 'sd', 'sd', 'gj', '23', '124325', '15436', '123456', '35346', '男', '2');
INSERT INTO `student` VALUES ('20155012', '徐工', '电话打', '说大话', '收到', '萨基', '25646', '1616', '123456', '164616', '男', '2');

-- ----------------------------
-- Table structure for `teacher`
-- ----------------------------
DROP TABLE IF EXISTS `teacher`;
CREATE TABLE `teacher` (
  `teacherId` int(9) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `teacherName` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '姓名',
  `institute` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '学院',
  `sex` varchar(2) COLLATE utf8_bin DEFAULT NULL COMMENT '性别',
  `tel` varchar(11) COLLATE utf8_bin DEFAULT NULL COMMENT '电话号码',
  `email` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '邮箱',
  `pwd` varchar(16) COLLATE utf8_bin DEFAULT NULL COMMENT '密码',
  `cardId` varchar(18) COLLATE utf8_bin DEFAULT NULL COMMENT '身份证号',
  `type` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '职称',
  `role` varchar(1) COLLATE utf8_bin DEFAULT NULL COMMENT '角色（0管理员，1教师，2学生）',
  PRIMARY KEY (`teacherId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=20081003 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='教师信息表';

-- ----------------------------
-- Records of teacher
-- ----------------------------
INSERT INTO `teacher` VALUES ('20081001', '张', '软件工程学院', '男', '13598458442', '13598458442@163.com', '123456', '423423283498', '讲师', '1');
INSERT INTO `teacher` VALUES ('20081002', '王大志', '软件工程学院', '男', '1231221312', '1231221312@163.com', '123456', '24241234', '讲师', '1');
